# I   { λx.x }
# M   { λf.f f }
# K   { λx.λy.x }
# C   { λf.λx.λy.f y x }
# KI  { C K } 
# KI  { K I } 
# B   { λf.λg.λx.f (g x) }
# T   { C I }
# V   { B C T }
# BBB { B B B }

# Id     { I  }
# ∘      { B  }
# Const  { K  }
# Flip   { C  }
# True   { K  }
# False  { KI }
# Not    { C  }
# And    { λp.λq.p q p }
# Or     { λp.λq.p p q }
# Or     { M }
# Beq    { λp.λq.p q (Not q) }
# Num    { λf.λx.[f] x }
# Zero   { False }
# Zero   { C K }
# One    { Id }
# One    { I }
# Succ   { λn.λf.B f (n f) }
# Add    { λm.λn.(m Succ n) } 
# Mul    { λm.λn.λf. m (n f) }
# Mul    { B }
# Pow    { T }
# IsZero { λn.n (K False) True }
# Pred { λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u) }
# Pred { λn.n(λg.IsZero (g Num[1]) I (B Succ g)) (K Num[0]) Num[0] }

# If { λv.λt.λf.v t f }
# Mkpair { λx.λy.λs.s x y }
# Fst { λp.p True }
# Snd { λp.p False }
# Add1 { λn.λf.λx.f (n f x) }
# AddN { λn.λm.m Add1 n } 
# Mult { λn.λm.m (AddN n) Zero }
# Exp { λn.λm.m (Mult n) One }
# Wrap { λf.λp. Mkpair (False) (If (Fst p) (Snd p) (f (Snd p))) }
# Sub1 { λn.λf.λx. Snd (n (Wrap f) (Mkpair True x)) }
# SubN { λn.λm.m Sub1 n }

Exp Num[4] Num[2]